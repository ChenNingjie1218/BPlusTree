# B+ Tree 任务报告

## 1 项目背景
B+Tree 原理、意义、应用场景等。
### 1.1 B+Tree原理
1. 完美平衡（每个叶节点都在同一层）
2. 除根节点外，其他节点都包含`n`个key，其中`⌈m/2⌉-1⩽n⩽m-1`
3. 每个有`n`个key的内部节点,都会有`n+1`个非空孩子
4. **每个内部节点仅保存关键字来索引**
5. **所有键值对内容都在叶子节点上** 

### 1.2 B+Tree的引入
如果设计一个查询系统，考虑选择怎样的数据结构
- 数组
只能顺序查询，时间复杂度为`O(n)`
- 哈希表
用哈希表(链地址法)存储**需要解决冲突**，且**数据分布不均匀**，最差的情况又退回成数组形式
- 二叉树
为加快查询速度，用二叉树存储，但如果插入顺序是有序的，会形成**单链**，从而使查询又退回数组形式
- 平衡二叉树
解决了二叉树的问题，但以牺牲建树的时间为代价。但对于插入操作过多的情况，将**消耗大量时间调整树的平衡**。
- 红黑树
最长子树不超过最短子树的**2倍**即可。减少了调整树的次数，但**数据量特别大**时，树太**高**
- B树
为解决树太高的问题，使一个节点存储多个数据。节点中保存数据量n，数据为键值对key-value,内部节点保存孩子指针p~n~。假设一个磁盘块16k，一个数据的value占1k，忽略其他成员，则一个节点只能放16个数据，3层B树只能存4096(16^3^)个数据。因此**无法存储大量数据**，如果**增加层高**，又回到了**树太高**的问题。
- B+树
每个内部节点仅保存关键字的索引及孩子指针，将数据键值对都存放在叶子节点中。

### 1.3 B+Tree的意义
1. 查询速度快：查找任何关键字都是`O(logn)`
2. 树高低：每个节点存储大量数据

### 1.4 B+Tree的应用场景
MySQL

## 2 详细设计
### 2.1 总体框架
![Alt text](res/B+%E6%A0%91%E7%B1%BB%E5%9B%BE.png)

### 2.2 关键流程

介绍插入、删除、查找、序列化、反序列化、并发控制等关键流程。
使用流程图、数据布局图等辅助说明。

#### 2.2.1 插入
![Alt text](res/%E6%8F%92%E5%85%A5.png)
#### 2.2.2 删除
![Alt text](res/%E5%88%A0%E9%99%A4.png)
#### 2.2.3 查找
![Alt text](res/%E6%9F%A5%E6%89%BE.png)
#### 2.2.4 范围查找
![Alt text](res/%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE.png)
#### 2.2.5 序列化
![Alt text](res/%E5%BA%8F%E5%88%97%E5%8C%96.png)
#### 2.2.6 反序列化
![Alt text](res/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png)
#### 2.2.7 并发控制
##### 2.2.7.1 插入并发
![Alt text](res/%E6%8F%92%E5%85%A5%E5%B9%B6%E5%8F%91.png)
##### 2.2.7.2 查询并发
![Alt text](res/%E6%9F%A5%E8%AF%A2%E5%B9%B6%E5%8F%91.png)
##### 2.2.7.3 删除并发
![Alt text](res/%E5%88%A0%E9%99%A4%E5%B9%B6%E5%8F%91.png)
## 3 代码实现

### 3.1 目录组织

介绍一下各目录的作用。
.
├── build
│   
├── doc:报告
│&emsp;&emsp;└── res:报告用的图
├── include:头文件
├── proto:proto文件生成的代码等
├── python:性能测试数据画图
├── src:源码
└── test:测试源码
&emsp;&emsp;&emsp;└── include：测试源码用的头文件


### 3.2 安装&测试
说明如何编译、安装、运行测试。
- 编译
```
在项目根目录下
cmake -S . -B ./build
cmake --build ./build
```
- 安装
```
可能需要用到的软件:
sudo apt install protobuf-compiler
sudo apt-get install uuid-dev
sudo apt-get install python3-pip
pip install gprof2dot
```
- 运行
```
在项目根目录下:
chmod +x run.sh
./run.sh
```
- 测试
```
在项目根目录下:
//单元测试
chmod +x unittest.sh
./unittest.sh

//性能测试
chmod +x performancetest.sh
./performancetest.sh

//性能测试结果画图输出到doc/res下:
chmod +x data2plot.sh
./data2plot.sh
```
### 3.3 接口

公共接口。
```
template<typename T>
void interface();
```
### 3.4 关键代码

重要或有意思的代码片段。


#### 3.4.1 由父节点控制分裂、合并、借
```
  /* 插入关键字 */
  void insertKey(const pair<T, uint64_t> &kv, const size_type &MAX_SIZE,
                 deque<shared_mutex *> &q_w_lock) override {
    if (this->isSafe(MAX_SIZE, true)) {
      while (q_w_lock.size() != 1) {
        q_w_lock.front()->unlock();
        q_w_lock.pop_front();
      }
    }
    size_type insertIndex = this->getInsertIndex(kv.first);
    BNode<T> *insertNode = p[insertIndex];
    insertNode->getMutex().lock();
    q_w_lock.push_back(&insertNode->getMutex());
    //默认不插入相等的key，都是左插
    insertNode->insertKey(kv, MAX_SIZE, q_w_lock);

    //孩子插入后需要分裂
    if (q_w_lock.size() > 1 && insertNode->getKeyNum() == MAX_SIZE) {
      pair<BNode<T> *, T> info = split(insertNode, MAX_SIZE);
      insertIndex = this->addKey(info.second);
      p.insert(p.begin() + insertIndex + 1, info.first);
    }

    if (!q_w_lock.empty()) {
      q_w_lock.back()->unlock();
      q_w_lock.pop_back();
    }
  }
  
  /* 删除关键字 */
  T deleteKey(const T &k, const size_type &MAX_SIZE,
              deque<shared_mutex *> &q_w_lock, bool &hasNewKey) override {
    if (!hasNewKey && this->isSafe(MAX_SIZE, false)) {
      while (q_w_lock.size() != 1) {
        q_w_lock.front()->unlock();
        q_w_lock.pop_front();
      }
    }

    size_type deleteIndex = this->getInsertIndex(k);
    T newKey;
    BNode<int> *deleteChild = p[deleteIndex];
    if (deleteIndex < this->_keyNum && k == this->_key[deleteIndex]) {
      ++deleteIndex;
      //遇见关键字向右找
      deleteChild = p[deleteIndex];
      deleteChild->getMutex().lock();
      q_w_lock.push_back(&deleteChild->getMutex());
      hasNewKey = true;
      newKey = deleteChild->deleteKey(k, MAX_SIZE, q_w_lock, hasNewKey);
      this->_key[deleteIndex - 1] = newKey;
    } else {
      deleteChild->getMutex().lock();
      q_w_lock.push_back(&deleteChild->getMutex());
      newKey = deleteChild->deleteKey(k, MAX_SIZE, q_w_lock, hasNewKey);
    }
    //孩子删除后需要借
    if (q_w_lock.size() > 1 &&
        deleteChild->getKeyNum() < ceil(1.0 * MAX_SIZE / 2) - 1) {
      q_w_lock.pop_back();
      if (deleteIndex + 1 < p.size()) {
        p[deleteIndex + 1]->getMutex().lock();
      }
      if (deleteIndex) {
        p[deleteIndex - 1]->getMutex().lock();
      }
      if (deleteIndex + 1 < p.size() &&
          p[deleteIndex + 1]->getKeyNum() > ceil(1.0 * MAX_SIZE / 2) - 1) {
        if (deleteIndex) {
          p[deleteIndex - 1]->getMutex().unlock();
        }
        //找右边兄弟借
        this->_key[deleteIndex] = deleteChild->borrowKey(
            p[deleteIndex + 1], true, this->_key[deleteIndex]);
        p[deleteIndex + 1]->getMutex().unlock();
        deleteChild->getMutex().unlock();
      } else if (deleteIndex && p[deleteIndex - 1]->getKeyNum() >
                                    ceil(1.0 * MAX_SIZE / 2) - 1) {
        //找左边兄弟借
        if (deleteIndex + 1 < p.size()) {
          p[deleteIndex + 1]->getMutex().unlock();
        }
        this->_key[deleteIndex - 1] = deleteChild->borrowKey(
            p[deleteIndex - 1], false, this->_key[deleteIndex - 1]);
        p[deleteIndex - 1]->getMutex().unlock();
        deleteChild->getMutex().unlock();
      } else if (deleteIndex + 1 < p.size()) {
        if (deleteIndex) {
          p[deleteIndex - 1]->getMutex().unlock();
        }
        //跟右兄弟合并
        merge(deleteChild, p[deleteIndex + 1], this->getKey(deleteIndex));
        deleteChild->getMutex().unlock();
        this->_key.erase(this->_key.begin() + deleteIndex);
        this->updateKeyNum();
        p.erase(p.begin() + deleteIndex + 1);
#ifndef NDEBUG
        cout << "-------------------跟右兄弟合并----------------------" << endl;
#endif
      } else {
        if (deleteIndex + 1 < p.size()) {
          p[deleteIndex + 1]->getMutex().unlock();
        }
        //跟左兄弟合并
        merge(p[deleteIndex - 1], deleteChild, this->getKey(deleteIndex - 1));
        p[deleteIndex - 1]->getMutex().unlock();
        this->_key.erase(this->_key.begin() + deleteIndex - 1);
        this->updateKeyNum();
        p.erase(p.begin() + deleteIndex);
#ifndef NDEBUG
        cout << "-------------------跟左兄弟合并----------------------" << endl;
#endif
      }
    } else if (!q_w_lock.empty()) {
      q_w_lock.back()->unlock();
      q_w_lock.pop_back();
    }
    return newKey;
  }
```
### 3.5 程序分析

内存泄漏分析，gprof/perf 代码性能分析。
- gprof
![Alt text](res/gprof.png)
## 4 测试

### 4.1 单元测试

#### 4.1.1 插入测试
##### 4.1.1.1 空树插入
测试用例:
```
---------------创建一课空的B+树--------------
 [ ]
---------------向B+树中插入<1, 1>--------------
 [ <1, 1> ]
```
##### 4.1.1.2 插入不导致分裂
测试用例:
```
 [ <1, 1> ]
---------------向B+树中插入<2, 2>--------------
 [ <1, 1> <2, 2> ]
```
##### 4.1.1.3 插入导致叶子节点分裂
测试用例:
```
[ <1, 1> <2, 2> ]
---------------向B+树中插入<3, 3>--------------
-------------------顶层节点满了---------------
 [2]
 [ <1, 1> ] [ <2, 2> <3, 3> ]
```
##### 4.1.1.4 插入导致顶部节点分裂
测试用例:
```
 [2 3]
 [ <1, 1> ] [ <2, 2> ] [ <3, 3> <4, 4> ]
---------------向B+树中插入<5, 5>--------------
-------------------顶层节点满了---------------
 [3]
 [2] [4]
 [ <1, 1> ] [ <2, 2> ] [ <3, 3> ] [ <4, 4> <5, 5> ]
```
##### 4.1.1.5 插入导致内部节点分裂
测试用例:
```
 [3]
 [2] [4 5]
 [ <1, 1> ] [ <2, 2> ] [ <3, 3> ] [ <4, 4> ] [ <5, 5> <6, 6> ]
---------------向B+树中插入<7, 7>--------------
 [3 5]
 [2] [4] [6]
 [ <1, 1> ] [ <2, 2> ] [ <3, 3> ] [ <4, 4> ] [ <5, 5> ] [ <6, 6> <7, 7> ]
```
#### 4.1.2 查找测试
查找树:
```
插入0到99关键字构成的树
```
##### 4.1.2.1 查找不存在的关键字
测试用例:
```
-1
1000001
```
##### 4.1.2.2 查找存在的关键字
测试用例:
```
0~99
```
#### 4.1.3 范围查找测试
查找树:
```
插入0到99关键字构成的树
```
##### 4.1.3.1 查找范围在范围外
测试用例:
```
-10 -5
200 300
```

##### 4.1.3.2 查找范围在范围内
测试用例:
```
1 4
31 90
```
##### 4.1.3.3 查找范围包含所有范围
测试用例:
```
-10 200
```
##### 4.1.3.4 查找范围包含一部分范围
测试用例:
```
-10 50
31 200
```
#### 4.1.4 删除测试
##### 4.1.4.1 删除不存在的关键字
测试用例:
```
 [50]
 [30 40] [75 80]
 [ <0, 0> <20, 20> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <80, 80> <100, 100> ]
------------------开始删除<-1>------------------
------------------开始删除<10>------------------
------------------开始删除<110>------------------
 [50]
 [30 40] [75 80]
 [ <0, 0> <20, 20> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <80, 80> <100, 100> ]
 
```
##### 4.1.4.2 删除不在路径上的关键字
测试用例:
```
 [50]
 [30 40] [75 80]
 [ <0, 0> <20, 20> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <80, 80> <100, 100> ]
------------------开始删除<20>------------------
----------------已删除<20, 20>-------------
 [50]
 [30 40] [75 80]
 [ <0, 0> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <80, 80> <100, 100> ]
```
##### 4.1.4.3 删除在最后一段路径上的关键字
测试用例:
```
 [50]
 [30 40] [75 80]
 [ <0, 0> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <80, 80> <100, 100> ]
------------------开始删除<80>------------------
----------------已删除<80, 80>-------------
 [50]
 [30 40] [75 100]
 [ <0, 0> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
```
##### 4.1.4.4 叶子节点向右兄弟借
测试用例:
```
 [50]
 [30 40] [75 100]
 [ <0, 0> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
------------------开始删除<30>------------------
----------------已删除<30, 30>-------------
-------------------叶子节点找右兄弟借40----------------------
 [50]
 [40 45] [75 100]
 [ <0, 0> ] [ <40, 40> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
```
##### 4.1.4.5 叶子节点向左兄弟借
测试用例:
```
 [50]
 [40 45] [75 100]
 [ <0, 0> <30, 30> ] [ <40, 40> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
------------------开始删除<40>------------------
----------------已删除<40, 40>-------------
-------------------叶子节点找左兄弟借30----------------------
 [50]
 [30 45] [75 100]
 [ <0, 0> ] [ <30, 30> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
```
##### 4.1.4.6 叶子节点跟右兄弟合并
测试用例:
```
 [50]
 [30 45] [75 100]
 [ <0, 0> ] [ <30, 30> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
------------------开始删除<0>------------------
----------------已删除<0, 0>-------------
-------------------跟右兄弟合并----------------------
 [50]
 [45] [75 100]
 [ <30, 30> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
```
##### 4.1.4.7 叶子节点跟左兄弟合并
测试用例:
```
[50]
 [45] [75 100]
 [ <30, 30> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
------------------开始删除<100>------------------
----------------已删除<100, 100>-------------
-------------------跟左兄弟合并----------------------
 [50]
 [45] [75]
 [ <30, 30> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ]
```
##### 4.1.4.8 删除在路径上的关键字，非最后一段路径
测试用例:
```
 [50]
 [45] [75]
 [ <30, 30> ] [ <45, 45> ] [ <50, 50> <60, 60> ] [ <75, 75> ]
------------------开始删除<50>------------------
----------------已删除<50, 50>-------------
 [60]
 [45] [75]
 [ <30, 30> ] [ <45, 45> ] [ <60, 60> ] [ <75, 75> ]
```

##### 4.1.4.9 内部节点跟右兄弟合并
测试用例:
```
[60]
 [45] [75]
 [ <30, 30> ] [ <45, 45> ] [ <60, 60> ] [ <75, 75> ]
------------------开始删除<30>------------------
----------------已删除<30, 30>-------------
-------------------跟右兄弟合并----------------------
-------------------跟右兄弟合并----------------------
 [60 75]
 [ <45, 45> ] [ <60, 60> ] [ <75, 75> ]
```
##### 4.1.4.10 内部节点跟左兄弟合并
测试用例:
```
[75]
 [60] [90]
 [ <45, 45> ] [ <60, 60> ] [ <75, 75> ] [ <90, 90> ]
------------------开始删除<90>------------------
----------------已删除<90, 90>-------------
-------------------跟左兄弟合并----------------------
-------------------跟左兄弟合并----------------------
 [60 75]
 [ <45, 45> ] [ <60, 60> ] [ <75, 75> ]
```
##### 4.1.4.11 内部节点借右兄弟
测试用例:
```
 [75]
 [60] [80 90]
 [ <45, 45> ] [ <60, 60> ] [ <75, 75> ] [ <80, 80> ] [ <90, 90> <100, 100> ]
------------------开始删除<45>------------------
----------------已删除<45, 45>-------------
-------------------跟右兄弟合并----------------------
-------------------内部节点找右兄弟借80----------------------
 [80]
 [75] [90]
 [ <60, 60> ] [ <75, 75> ] [ <80, 80> ] [ <90, 90> <100, 100> ]
```
##### 4.1.4.12 内部节点借左兄弟
测试用例:
```
[80]
 [50 75] [90]
 [ <40, 40> ] [ <50, 50> <60, 60> ] [ <75, 75> ] [ <80, 80> ] [ <90, 90> ]
------------------开始删除<80>------------------
----------------已删除<80, 80>-------------
-------------------跟右兄弟合并----------------------
-------------------内部节点找左兄弟借75----------------------
 [75]
 [50] [90]
 [ <40, 40> ] [ <50, 50> <60, 60> ] [ <75, 75> ] [ <90, 90> ]
```
##### 4.1.4.13 删除至空树
测试用例:
```
 [75]
 [50] [90]
 [ <40, 40> ] [ <50, 50> <60, 60> ] [ <75, 75> ] [ <90, 90> ]
------------------开始删除<40>------------------
----------------已删除<40, 40>-------------
-------------------叶子节点找右兄弟借50----------------------
------------------开始删除<50>------------------
----------------已删除<50, 50>-------------
-------------------跟右兄弟合并----------------------
-------------------跟右兄弟合并----------------------
------------------开始删除<60>------------------
----------------已删除<60, 60>-------------
-------------------跟右兄弟合并----------------------
------------------开始删除<75>------------------
----------------已删除<75, 75>-------------
-------------------跟右兄弟合并----------------------
 [ <90, 90> ]
------------------开始删除<90>------------------
----------------已删除<90, 90>-------------
 [ ]
```
#### 4.1.5 序列化与反序列化测试
测试用例:
```
将查找时用的查找树序列化后，用另一个变量存反序列化后树
与测试树进行层序遍历和全遍历输出的对比。
```

#### 4.1.6 并发测试
测试用例:
```
向查找树用三个线程并发插入100个数据（100~199、200~299、300~399）
同时两个线程查找100个数据（0~99、100~199）

全遍历叶子节点，看是否插入正确

将刚刚的结构树用三个线程并发删除100个数据(100~199、200~299、300~399)
全遍历叶子节点，看是否删除正确
```
#### 4.1.7 测试结果
```
[==========] Running 7 tests from 2 test suites.
[----------] Global test environment set-up.
[----------] 2 tests from NULLTREE
[ RUN      ] NULLTREE.insert_test
[       OK ] NULLTREE.insert_test (0 ms)
[ RUN      ] NULLTREE.delete_test
[       OK ] NULLTREE.delete_test (0 ms)
[----------] 2 tests from NULLTREE (0 ms total)

[----------] 5 tests from SEARCH_TREE
[ RUN      ] SEARCH_TREE.search_test
[       OK ] SEARCH_TREE.search_test (0 ms)
[ RUN      ] SEARCH_TREE.range_search_test
[       OK ] SEARCH_TREE.range_search_test (0 ms)
[ RUN      ] SEARCH_TREE.output_all_the_keys_test
[       OK ] SEARCH_TREE.output_all_the_keys_test (0 ms)
[ RUN      ] SEARCH_TREE.serialize_and_deserialize_test
[       OK ] SEARCH_TREE.serialize_and_deserialize_test (26 ms)
[ RUN      ] SEARCH_TREE.Concurrent
[       OK ] SEARCH_TREE.Concurrent (129 ms)
[----------] 5 tests from SEARCH_TREE (163 ms total)

[----------] Global test environment tear-down
[==========] 7 tests from 2 test suites ran. (163 ms total)
[  PASSED  ] 7 tests.
```
### 4.2 性能测试
#### 4.2.1 不同度数下的性能测试
测试用例:
```
最小度数为3，最大度数为1000，步长为5，样本数量1000000
```
结果图:
![Alt text](res/performance.png)
#### 4.2.2 不同线程数下的性能测试
测试用例:
```
最小线程数为1，最大线程数为99，步长为1，样本数量为1000000，样本度数为100
```
结果图:
![Alt text](res/performance_thread.png)
## 5 总结

总结困难问题的解决思路，以及收获与心得体会。
- 模板的头文件包括声明及定义导致只有`.h`文件，但是`Main.cpp`里面找不到头文件
解决方案1：不知道为啥`${}`括起来的几种形式，`include_directories`识别不到正确的位置，改成**相对路径**得以解决

- 设计时，想把`key`设置成一个`pair`，简化插入删除等操作。叶子节点存**键值对**，内部节点存**键和左边孩子的指针**。该`key`成员第二个类型模版参数列表只能放在类外，导致叶子节点跟内部节点并**没有继承同一个基类**。(实例化的不一样，`BNode<T, BNode<T>*>` 和 `BNode<T, uint64_t*>`)最后放弃了该设计。

- 查找成功标志的问题
想要查找成功返回一个`pair`键值对，查找失败返回`NULL`。但是`NULL`并不能作为`pair`的返回值，而`value`部分并不能作为**标志**
解决方案：节点中不存**值的内容**，改为存指向内容的**指针**，返回的`pair`中`value`部分为空标识查找失败

- 分裂的优化
最初方案：利用拷贝构造函数直接拷贝一整个节点，然后去首或去尾
优化方案1：编写特殊的构造函数，只拷贝需要的部分（可不可以移动过去？）

- 合并的优化
最初方案：将另一节点数据拷贝过去
优化方案1：将另一节点数据移动过去

- 范围查找的优化
最初方案：遍历完该节点，遍历右兄弟的时候，走的同样的逻辑，导致又二分查找了一次
优化方案1：横向遍历的时候不再二分查找，传入默认参数`continueFlag`

- OOP优化
最初方案：建树、插入、查找、范围查找、BFS等大操作都是面向过程，且`MAX_SIZE`没有封装
优化方案1：将上述操作放入一个类中实现面向对象

- `MAX_SIZE`访问的问题
封装后可以实现一个B+树对象，一个度。但是，节点类如何访问到该成员？（在节点类内丢失了树类对象，无法使用`get`方法获取）
解决方案1：在节点类需要用到的地方，都传入该参数，但会使节点类的各个成员函数参数列表显得很复杂。(采用)
解决方案2：为节点类添加成员，虽然可以解决问题，但是浪费内存。

- 序列化反序列化
问题1：没找到一种好的方法利用protobuf对模板进行序列化。目前仅支持一种类型的序列化。原本想的是利用`is_same<type1,type2>::value`来判断，但是进入分支用反序列化的数据构造时编译器会报错(我接受`int`但是你可能传的`string`,即编译器不能通过分支自动推断类型的感觉)。并且在构造函数**初始化列表**中，想使用三目运算符来选择使用，编译器也会报错(返回的两种类型不一样)。

问题2：采用的全局序列化，每次只能序列化、反序列化整棵树，虽然采用了为树起名、为节点分配`uuid`将树和每个节点存放在不同文件，同一个文件夹下的方法，但实现局部序列化仍然较为困难。特别是到底局部序列化多少结点，`next`和`prev`的使用等，想到的方案是在所有用孩子节点、`next`和`prev`等东西的地方判断是否已经序列化，但是会大量修改代码，工作量巨大。并且何时写回也成了问题，每次改就写回效率底下，延迟写回又会有最终一致性问题，问题规模变得复杂。

- 并发编程的问题
问题1：学习了`RAII`思想，但并不是一定要用`RAII`思想。特别要注意使用`shared_lock`和`unique_lock`时，主动调用了析构函数，在它析构时还会自动调用析构函数。解决方案1：最好调用`unlock()`方法，这样析构时不会再进入它析构函数中的`if`分支（`_M_owns`在主动调用`unlock()`时会改变，在析构时不会）。

问题2：忽略了锁树，直接从根节点开始锁。如果是删除将根节点删了，然后解锁，其他等待根节点的线程会找不到对象。

问题3：由于采取的递归算法，由父节点判断孩子是否需要分裂、合并、借等操作。问题之一是：此时用的孩子还是不是原来的那个孩子（比如之前只存了孩子的index，此时的p[index]已经不是原来那个了而被其他线程修改了内容。）。问题二是：递归回去路上，仍旧在访问该节点的内容，跟是否持锁无关。
解决方案1：用临时变量存下孩子，后面都使用这个变量。访问内容时，首先判断持锁队列是否`size`大于1（至少要有孩子的锁和自己的锁），这样你才会是要进入分裂、合并、借的操作的那个线程。

问题4：**范围查找与其他操作的死锁问题没有解决**