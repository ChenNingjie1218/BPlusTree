# B+ Tree 任务报告

## 1 项目背景
B+Tree 原理、意义、应用场景等。
### 1.1 B+Tree原理
1. 完美平衡（每个叶节点都在同一层）
2. 除根节点外，其他节点都包含`n`个key，其中`⌈m/2⌉-1⩽n⩽m-1`
3. 每个有`n`个key的内部节点,都会有`n+1`个非空孩子
4. **每个内部节点仅保存关键字来索引**
5. **所有键值对内容都在叶子节点上** 

### 1.2 B+Tree的引入
如果设计一个查询系统，考虑选择怎样的数据结构
- 数组
只能顺序查询，时间复杂度为`O(n)`
- 哈希表
用哈希表(链地址法)存储**需要解决冲突**，且**数据分布不均匀**，最差的情况又退回成数组形式
- 二叉树
为加快查询速度，用二叉树存储，但如果插入顺序是有序的，会形成**单链**，从而使查询又退回数组形式
- 平衡二叉树
解决了二叉树的问题，但以牺牲建树的时间为代价。但对于插入操作过多的情况，将**消耗大量时间调整树的平衡**。
- 红黑树
最长子树不超过最短子树的**2倍**即可。减少了调整树的次数，但**数据量特别大**时，树太**高**
- B树
为解决树太高的问题，使一个节点存储多个数据。节点中保存数据量n，数据为键值对key-value,内部节点保存孩子指针p~n~。假设一个磁盘块16k，一个数据的value占1k，忽略其他成员，则一个节点只能放16个数据，3层B树只能存4096(16^3^)个数据。因此**无法存储大量数据**，如果**增加层高**，又回到了**树太高**的问题。
- B+树
每个内部节点仅保存关键字的索引及孩子指针，将数据键值对都存放在叶子节点中。

### 1.3 B+Tree的意义
1. 查询速度快：查找任何关键字都是`O(logn)`
2. 树高低：每个节点存储大量数据

### 1.4 B+Tree的应用场景
MySQL

## 2 详细设计
### 2.1 总体框架
![Alt text](res/B+%E6%A0%91%E7%B1%BB%E5%9B%BE.png)

### 2.2 关键流程

介绍插入、删除、查找、序列化、反序列化、并发控制等关键流程。
使用流程图、数据布局图等辅助说明。

#### 2.2.1 插入
![Alt text](res/%E6%8F%92%E5%85%A5.png)
#### 2.2.2 删除
![Alt text](res/%E5%88%A0%E9%99%A4.png)
#### 2.2.3 查找
![Alt text](res/%E6%9F%A5%E6%89%BE.png)
#### 2.2.4 范围查找
![Alt text](res/%E8%8C%83%E5%9B%B4%E6%9F%A5%E6%89%BE.png)
#### 2.2.5 序列化
![Alt text](res/%E5%BA%8F%E5%88%97%E5%8C%96.png)
#### 2.2.6 反序列化
![Alt text](res/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png)
#### 2.2.7 并发控制
##### 2.2.7.1 插入并发
![Alt text](res/%E6%8F%92%E5%85%A5%E5%B9%B6%E5%8F%91.png)
##### 2.2.7.2 查询并发
![Alt text](res/%E6%9F%A5%E8%AF%A2%E5%B9%B6%E5%8F%91.png)
##### 2.2.7.3 删除并发
![Alt text](res/%E5%88%A0%E9%99%A4%E5%B9%B6%E5%8F%91.png)
## 3 代码实现

### 3.1 目录组织

介绍一下各目录的作用。
.
├── build
│   
├── doc:报告
│&emsp;&emsp;└── res:报告用的图
├── include:头文件
├── proto:proto文件生成的代码等
├── python:性能测试数据画图
├── src:源码
└── test:测试源码
&emsp;&emsp;&emsp;└── include：测试源码用的头文件


### 3.2 安装&测试
说明如何编译、安装、运行测试。

### 3.3 接口

公共接口。
```
template<typename T>
void interface();


```
### 3.4 关键代码

重要或有意思的代码片段。
#### 3.4.1 分裂时使用的特殊构造函数
```
  /**
   * @brief 分裂用的特殊构造函数
   * @param SIZE 从_key的多少位开始
   * */
  BNode(BNode<T> *bnode, const size_type &SIZE)
      : _isLeaf(bnode->isLeaf()),
        _key(make_move_iterator(bnode->_key.begin() + SIZE),
             make_move_iterator(bnode->_key.end())) {
    updateKeyNum();
  }

  /* 分裂用的特殊构造函数 */
  LeafBNode(LeafBNode *&leafbnode, const size_type &MAX_SIZE)
      : BNode<T>(leafbnode, MAX_SIZE / 2),
        _next(leafbnode->_next),
        _prev(leafbnode),
        _value(make_move_iterator(leafbnode->_value.begin() + MAX_SIZE / 2),
               make_move_iterator(leafbnode->_value.end())) {}

  /* 内部节点分裂用的特殊构造函数 */
  InnerBNode(InnerBNode<T> *&innerbnode, const size_type &MAX_SIZE)
      : BNode<T>(innerbnode, MAX_SIZE / 2 + 1),
        p(make_move_iterator(innerbnode->p.begin() + MAX_SIZE / 2 + 1),
          make_move_iterator(innerbnode->p.end())) {}

  //顶层分裂调用
  InnerBNode(BNode<T> *const &root, const size_type &MAX_SIZE)
      : BNode<T>(false) {
    pair<BNode<T> *, T> info = split(root, MAX_SIZE);
    this->addKey(info.second);
    p.push_back(root);
    p.push_back(info.first);
  }
```
#### 3.4.2 移动后源对象即时放弃所有权
```
  /* 合并时，value移动后清空value的vector，以免析构的时候把值清了*/
  void clearValues() { _value.clear(); }
```

#### 3.4.3 由父节点控制分裂
```
  /* 插入关键字 */
  void insertKey(const pair<T, uint64_t> &kv,
                 const size_type &MAX_SIZE) override {
    size_type insertIndex = this->getInsertIndex(kv.first);
    //默认不插入相等的key，都是左插
    p[insertIndex]->insertKey(kv, MAX_SIZE);

    //孩子插入后需要分裂
    if (p[insertIndex]->getKeyNum() == MAX_SIZE) {
      pair<BNode<T> *, T> info = split(p[insertIndex], MAX_SIZE);
      insertIndex = this->addKey(info.second);
      p.insert(p.begin() + insertIndex + 1, info.first);
    }
  }
```
### 3.5 程序分析

内存泄漏分析，gprof/perf 代码性能分析。

## 4 测试

### 4.1 单元测试

#### 4.1.1 插入测试
##### 4.1.1.1 空树插入
测试用例:
```
---------------创建一课空的B+树--------------
 [ ]
---------------向B+树中插入<1, 1>--------------
 [ <1, 1> ]
```
##### 4.1.1.2 插入不导致分裂
测试用例:
```
 [ <1, 1> ]
---------------向B+树中插入<2, 2>--------------
 [ <1, 1> <2, 2> ]
```
##### 4.1.1.3 插入导致叶子节点分裂
测试用例:
```
[ <1, 1> <2, 2> ]
---------------向B+树中插入<3, 3>--------------
-------------------顶层节点满了---------------
 [2]
 [ <1, 1> ] [ <2, 2> <3, 3> ]
```
##### 4.1.1.4 插入导致顶部节点分裂
测试用例:
```
 [2 3]
 [ <1, 1> ] [ <2, 2> ] [ <3, 3> <4, 4> ]
---------------向B+树中插入<5, 5>--------------
-------------------顶层节点满了---------------
 [3]
 [2] [4]
 [ <1, 1> ] [ <2, 2> ] [ <3, 3> ] [ <4, 4> <5, 5> ]
```
##### 4.1.1.5 插入导致内部节点分裂
测试用例:
```
 [3]
 [2] [4 5]
 [ <1, 1> ] [ <2, 2> ] [ <3, 3> ] [ <4, 4> ] [ <5, 5> <6, 6> ]
---------------向B+树中插入<7, 7>--------------
 [3 5]
 [2] [4] [6]
 [ <1, 1> ] [ <2, 2> ] [ <3, 3> ] [ <4, 4> ] [ <5, 5> ] [ <6, 6> <7, 7> ]
```
#### 4.1.2 查找测试
查找树:
```
插入0到99关键字构成的树
```
##### 4.1.2.1 查找不存在的关键字
测试用例:
```
-1
1000001
```
##### 4.1.2.2 查找存在的关键字
测试用例:
```
0~99
```
#### 4.1.3 范围查找测试
查找树:
```
插入0到99关键字构成的树
```
##### 4.1.3.1 查找范围在范围外
测试用例:
```
-10 -5
200 300
```

##### 4.1.3.2 查找范围在范围内
测试用例:
```
1 4
31 90
```
##### 4.1.3.3 查找范围包含所有范围
测试用例:
```
-10 200
```
##### 4.1.3.4 查找范围包含一部分范围
测试用例:
```
-10 50
31 200
```
#### 4.1.4 删除测试
##### 4.1.4.1 删除不存在的关键字
测试用例:
```
 [50]
 [30 40] [75 80]
 [ <0, 0> <20, 20> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <80, 80> <100, 100> ]
------------------开始删除<-1>------------------
------------------开始删除<10>------------------
------------------开始删除<110>------------------
 [50]
 [30 40] [75 80]
 [ <0, 0> <20, 20> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <80, 80> <100, 100> ]
 
```
##### 4.1.4.2 删除不在路径上的关键字
测试用例:
```
 [50]
 [30 40] [75 80]
 [ <0, 0> <20, 20> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <80, 80> <100, 100> ]
------------------开始删除<20>------------------
----------------已删除<20, 20>-------------
 [50]
 [30 40] [75 80]
 [ <0, 0> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <80, 80> <100, 100> ]
```
##### 4.1.4.3 删除在最后一段路径上的关键字
测试用例:
```
 [50]
 [30 40] [75 80]
 [ <0, 0> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <80, 80> <100, 100> ]
------------------开始删除<80>------------------
----------------已删除<80, 80>-------------
 [50]
 [30 40] [75 100]
 [ <0, 0> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
```
##### 4.1.4.4 叶子节点向右兄弟借
测试用例:
```
 [50]
 [30 40] [75 100]
 [ <0, 0> ] [ <30, 30> ] [ <40, 40> <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
------------------开始删除<30>------------------
----------------已删除<30, 30>-------------
-------------------叶子节点找右兄弟借40----------------------
 [50]
 [40 45] [75 100]
 [ <0, 0> ] [ <40, 40> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
```
##### 4.1.4.5 叶子节点向左兄弟借
测试用例:
```
 [50]
 [40 45] [75 100]
 [ <0, 0> <30, 30> ] [ <40, 40> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
------------------开始删除<40>------------------
----------------已删除<40, 40>-------------
-------------------叶子节点找左兄弟借30----------------------
 [50]
 [30 45] [75 100]
 [ <0, 0> ] [ <30, 30> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
```
##### 4.1.4.6 叶子节点跟右兄弟合并
测试用例:
```
 [50]
 [30 45] [75 100]
 [ <0, 0> ] [ <30, 30> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
------------------开始删除<0>------------------
----------------已删除<0, 0>-------------
-------------------跟右兄弟合并----------------------
 [50]
 [45] [75 100]
 [ <30, 30> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
```
##### 4.1.4.7 叶子节点跟左兄弟合并
测试用例:
```
[50]
 [45] [75 100]
 [ <30, 30> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ] [ <100, 100> ]
------------------开始删除<100>------------------
----------------已删除<100, 100>-------------
-------------------跟左兄弟合并----------------------
 [50]
 [45] [75]
 [ <30, 30> ] [ <45, 45> ] [ <50, 50> ] [ <75, 75> ]
```
##### 4.1.4.8 删除在路径上的关键字，非最后一段路径
测试用例:
```
 [50]
 [45] [75]
 [ <30, 30> ] [ <45, 45> ] [ <50, 50> <60, 60> ] [ <75, 75> ]
------------------开始删除<50>------------------
----------------已删除<50, 50>-------------
 [60]
 [45] [75]
 [ <30, 30> ] [ <45, 45> ] [ <60, 60> ] [ <75, 75> ]
```

##### 4.1.4.9 内部节点跟右兄弟合并
测试用例:
```
[60]
 [45] [75]
 [ <30, 30> ] [ <45, 45> ] [ <60, 60> ] [ <75, 75> ]
------------------开始删除<30>------------------
----------------已删除<30, 30>-------------
-------------------跟右兄弟合并----------------------
-------------------跟右兄弟合并----------------------
 [60 75]
 [ <45, 45> ] [ <60, 60> ] [ <75, 75> ]
```
##### 4.1.4.10 内部节点跟左兄弟合并
测试用例:
```
[75]
 [60] [90]
 [ <45, 45> ] [ <60, 60> ] [ <75, 75> ] [ <90, 90> ]
------------------开始删除<90>------------------
----------------已删除<90, 90>-------------
-------------------跟左兄弟合并----------------------
-------------------跟左兄弟合并----------------------
 [60 75]
 [ <45, 45> ] [ <60, 60> ] [ <75, 75> ]
```
##### 4.1.4.11 内部节点借右兄弟
测试用例:
```
 [75]
 [60] [80 90]
 [ <45, 45> ] [ <60, 60> ] [ <75, 75> ] [ <80, 80> ] [ <90, 90> <100, 100> ]
------------------开始删除<45>------------------
----------------已删除<45, 45>-------------
-------------------跟右兄弟合并----------------------
-------------------内部节点找右兄弟借80----------------------
 [80]
 [75] [90]
 [ <60, 60> ] [ <75, 75> ] [ <80, 80> ] [ <90, 90> <100, 100> ]
```
##### 4.1.4.12 内部节点借左兄弟
测试用例:
```
[80]
 [50 75] [90]
 [ <40, 40> ] [ <50, 50> <60, 60> ] [ <75, 75> ] [ <80, 80> ] [ <90, 90> ]
------------------开始删除<80>------------------
----------------已删除<80, 80>-------------
-------------------跟右兄弟合并----------------------
-------------------内部节点找左兄弟借75----------------------
 [75]
 [50] [90]
 [ <40, 40> ] [ <50, 50> <60, 60> ] [ <75, 75> ] [ <90, 90> ]
```
##### 4.1.4.13 删除至空树
测试用例:
```
 [75]
 [50] [90]
 [ <40, 40> ] [ <50, 50> <60, 60> ] [ <75, 75> ] [ <90, 90> ]
------------------开始删除<40>------------------
----------------已删除<40, 40>-------------
-------------------叶子节点找右兄弟借50----------------------
------------------开始删除<50>------------------
----------------已删除<50, 50>-------------
-------------------跟右兄弟合并----------------------
-------------------跟右兄弟合并----------------------
------------------开始删除<60>------------------
----------------已删除<60, 60>-------------
-------------------跟右兄弟合并----------------------
------------------开始删除<75>------------------
----------------已删除<75, 75>-------------
-------------------跟右兄弟合并----------------------
 [ <90, 90> ]
------------------开始删除<90>------------------
----------------已删除<90, 90>-------------
 [ ]
```
#### 4.1.5 序列化与反序列化测试
测试用例:
```
将查找时用的查找树序列化后，用另一个变量存反序列化后树
与测试树进行层序遍历和全遍历输出的对比。
```

#### 4.1.6 并发测试
测试用例:
```
向查找树用三个线程并发插入100个数据（100~199、200~299、300~399）
同时两个线程查找100个数据（0~99、100~199）

全遍历叶子节点，看是否插入正确

将刚刚的结构树用三个线程并发删除100个数据(100~199、200~299、300~399)
全遍历叶子节点，看是否删除正确
```
#### 4.1.7 测试结果
```
[==========] Running 7 tests from 2 test suites.
[----------] Global test environment set-up.
[----------] 2 tests from NULLTREE
[ RUN      ] NULLTREE.insert_test
[       OK ] NULLTREE.insert_test (0 ms)
[ RUN      ] NULLTREE.delete_test
[       OK ] NULLTREE.delete_test (0 ms)
[----------] 2 tests from NULLTREE (0 ms total)

[----------] 5 tests from SEARCH_TREE
[ RUN      ] SEARCH_TREE.search_test
[       OK ] SEARCH_TREE.search_test (0 ms)
[ RUN      ] SEARCH_TREE.range_search_test
[       OK ] SEARCH_TREE.range_search_test (0 ms)
[ RUN      ] SEARCH_TREE.output_all_the_keys_test
[       OK ] SEARCH_TREE.output_all_the_keys_test (0 ms)
[ RUN      ] SEARCH_TREE.serialize_and_deserialize_test
[       OK ] SEARCH_TREE.serialize_and_deserialize_test (26 ms)
[ RUN      ] SEARCH_TREE.Concurrent
[       OK ] SEARCH_TREE.Concurrent (129 ms)
[----------] 5 tests from SEARCH_TREE (163 ms total)

[----------] Global test environment tear-down
[==========] 7 tests from 2 test suites ran. (163 ms total)
[  PASSED  ] 7 tests.
```
### 4.2 性能测试
#### 4.2.1 不同度数下的性能测试
测试用例:
```
最小度数为3，最大度数为1000，步长为5，样本数量100000
```
插入结果图:

查询结果图:

删除结果图:
#### 4.2.2 不同线程数下的性能测试

```

```

## 5 总结

总结困难问题的解决思路，以及收获与心得体会。
- 模板的头文件包括声明及定义导致只有`.h`文件，但是`Main.cpp`里面找不到头文件
解决方案1：不知道为啥`${}`括起来的几种形式，`include_directories`识别不到正确的位置，改成**相对路径**得以解决

- 设计时，想把`key`设置成一个`pair`，简化插入删除等操作。叶子节点存**键值对**，内部节点存**键和左边孩子的指针**。该`key`成员第二个类型模版参数列表只能放在类外，导致叶子节点跟内部节点并**没有继承同一个基类**。(实例化的不一样，`BNode<T, BNode<T>*>` 和 `BNode<T, uint64_t*>`)最后放弃了该设计。

- 查找成功标志的问题
想要查找成功返回一个`pair`键值对，查找失败返回`NULL`。但是`NULL`并不能作为`pair`的返回值，而`value`部分并不能作为**标志**
解决方案：节点中不存**值的内容**，改为存指向内容的**指针**，返回的`pair`中`value`部分为空标识查找失败

- 分裂的优化
最初方案：利用拷贝构造函数直接拷贝一整个节点，然后去首或去尾
优化方案1：编写特殊的构造函数，只拷贝需要的部分（可不可以移动过去？）

- 合并的优化
最初方案：将另一节点数据拷贝过去
优化方案1：将另一节点数据移动过去

- 范围查找的优化
最初方案：遍历完该节点，遍历右兄弟的时候，走的同样的逻辑，导致又二分查找了一次
优化方案1：横向遍历的时候不再二分查找，传入默认参数`continueFlag`

- OOP优化
最初方案：建树、插入、查找、范围查找、BFS等大操作都是面向过程，且`MAX_SIZE`没有封装
优化方案1：将上述操作放入一个类中实现面向对象

- `MAX_SIZE`访问的问题
封装后可以实现一个B+树对象，一个度。但是，节点类如何访问到该成员？（在节点类内丢失了树类对象，无法使用`get`方法获取）
解决方案1：在节点类需要用到的地方，都传入该参数，但会使节点类的各个成员函数参数列表显得很复杂。(采用)
解决方案2：为节点类添加成员，虽然可以解决问题，但是浪费内存。